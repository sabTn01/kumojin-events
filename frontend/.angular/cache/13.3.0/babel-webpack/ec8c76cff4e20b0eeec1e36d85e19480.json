{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar win = null;\n\ntry {\n  win = window;\n} catch (e) {\n  win = global;\n} //some other modules might want access to the serialization meta data, expose it here\n\n\nvar TypeMap = win.__CerializeTypeMap = new win.Map();\nexports.__TypeMap = TypeMap; //convert strings like my_camel_string to myCamelString\n\nfunction CamelCase(str) {\n  var STRING_CAMELIZE_REGEXP = /(\\-|_|\\.|\\s)+(.)?/g;\n  return str.replace(STRING_CAMELIZE_REGEXP, function (match, separator, chr) {\n    return chr ? chr.toUpperCase() : '';\n  }).replace(/^([A-Z])/, function (match, separator, chr) {\n    return match.toLowerCase();\n  });\n}\n\nexports.CamelCase = CamelCase; //convert strings like MyCamelString to my_camel_string\n\nfunction SnakeCase(str) {\n  var STRING_DECAMELIZE_REGEXP = /([a-z\\d])([A-Z])/g;\n  return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();\n}\n\nexports.SnakeCase = SnakeCase; //convert strings like myCamelCase to my_camel_case\n\nfunction UnderscoreCase(str) {\n  var STRING_UNDERSCORE_REGEXP_1 = /([a-z\\d])([A-Z]+)/g;\n  var STRING_UNDERSCORE_REGEXP_2 = /\\-|\\s+/g;\n  return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();\n}\n\nexports.UnderscoreCase = UnderscoreCase; //convert strings like my_camelCase to my-camel-case\n\nfunction DashCase(str) {\n  var STRING_DASHERIZE_REGEXP = /([a-z\\d])([A-Z])/g;\n  str = str.replace(/_/g, '-');\n  return str.replace(STRING_DASHERIZE_REGEXP, '$1-$2').toLowerCase();\n}\n\nexports.DashCase = DashCase;\n\nfunction deserializeString(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return element && element.toString() || null;\n    });\n  } else {\n    return value && value.toString() || null;\n  }\n}\n\nfunction deserializeNumber(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return parseFloat(element);\n    });\n  } else {\n    return parseFloat(value);\n  }\n}\n\nfunction deserializeBoolean(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return Boolean(element);\n    });\n  } else {\n    return Boolean(value);\n  }\n}\n\nfunction serializeString(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return element && element.toString() || null;\n    });\n  } else {\n    return value && value.toString() || null;\n  }\n}\n\nfunction serializeNumber(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return parseInt(element);\n    });\n  } else {\n    return parseInt(value);\n  }\n}\n\nfunction serializeBoolean(value) {\n  if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return Boolean(element);\n    });\n  } else {\n    return Boolean(value);\n  }\n}\n\nfunction getDeserializeFnForType(type) {\n  if (type === String) {\n    return deserializeString;\n  } else if (type === Number) {\n    return deserializeNumber;\n  } else if (type === Boolean) {\n    return deserializeBoolean;\n  } else {\n    return type;\n  }\n}\n\nfunction getSerializeFnForType(type) {\n  if (type === String) {\n    return serializeString;\n  } else if (type === Number) {\n    return serializeNumber;\n  } else if (type === Boolean) {\n    return serializeBoolean;\n  } else {\n    return type;\n  }\n} //gets meta data for a key name, creating a new meta data instance\n//if the input array doesn't already define one for the given keyName\n\n\nfunction getMetaData(array, keyName) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i].keyName === keyName) {\n      return array[i];\n    }\n  }\n\n  array.push(new MetaData(keyName));\n  return array[array.length - 1];\n} //helper for grabbing the type and keyname from a multi-type input variable\n\n\nfunction getTypeAndKeyName(keyNameOrType, keyName) {\n  var type = null;\n  var key = null;\n\n  if (typeof keyNameOrType === \"string\") {\n    key = keyNameOrType;\n  } else if (keyNameOrType && typeof keyNameOrType === \"function\" || typeof keyNameOrType === \"object\") {\n    type = keyNameOrType;\n    key = keyName;\n  }\n\n  return {\n    key: key,\n    type: type\n  };\n} //todo instance.constructor.prototype.__proto__ === parent class, maybe use this?\n//because types are stored in a JS Map keyed by constructor, serialization is not inherited by default\n//keeping this seperate by default also allows sub classes to serialize differently than their parent\n\n\nfunction inheritSerialization(parentType) {\n  return function (childType) {\n    var parentMetaData = TypeMap.get(parentType) || [];\n    var childMetaData = TypeMap.get(childType) || [];\n\n    for (var i = 0; i < parentMetaData.length; i++) {\n      var keyName = parentMetaData[i].keyName;\n\n      if (!MetaData.hasKeyName(childMetaData, keyName)) {\n        childMetaData.push(MetaData.clone(parentMetaData[i]));\n      }\n    }\n\n    TypeMap.set(childType, childMetaData);\n  };\n}\n\nexports.inheritSerialization = inheritSerialization; //an untyped serialization property annotation, gets existing meta data for the target or creates\n//a new one and assigns the serialization key for that type in the meta data\n\nfunction serialize(target, keyName) {\n  if (!target || !keyName) return;\n  var metaDataList = TypeMap.get(target.constructor) || [];\n  var metadata = getMetaData(metaDataList, keyName);\n  metadata.serializedKey = keyName;\n  TypeMap.set(target.constructor, metaDataList);\n}\n\nexports.serialize = serialize; //an untyped deserialization property annotation, gets existing meta data for the target or creates\n//a new one and assigns the deserialization key for that type in the meta data\n\nfunction deserialize(target, keyName) {\n  if (!target || !keyName) return;\n  var metaDataList = TypeMap.get(target.constructor) || [];\n  var metadata = getMetaData(metaDataList, keyName);\n  metadata.deserializedKey = keyName;\n  TypeMap.set(target.constructor, metaDataList);\n}\n\nexports.deserialize = deserialize; //this combines @serialize and @deserialize as defined above\n\nfunction autoserialize(target, keyName) {\n  if (!target || !keyName) return;\n  var metaDataList = TypeMap.get(target.constructor) || [];\n  var metadata = getMetaData(metaDataList, keyName);\n  metadata.serializedKey = keyName;\n  metadata.deserializedKey = keyName;\n  TypeMap.set(target.constructor, metaDataList);\n}\n\nexports.autoserialize = autoserialize; //We dont actually need the type to serialize but I like the consistency with deserializeAs which definitely does\n//serializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\n\nfunction serializeAs(keyNameOrType, keyName) {\n  if (!keyNameOrType) return;\n\n  var _a = getTypeAndKeyName(keyNameOrType, keyName),\n      key = _a.key,\n      type = _a.type;\n\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    metadata.serializedKey = key ? key : actualKeyName;\n    metadata.serializedType = type; //this allows the type to be a stand alone function instead of a class\n\n    if (type !== Date && type !== RegExp && !TypeMap.get(type) && typeof type === \"function\") {\n      metadata.serializedType = {\n        Serialize: getSerializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.serializeAs = serializeAs; //Supports serializing of dictionary-like map objects, ie: { x: {}, y: {} }\n\nfunction serializeIndexable(type, keyName) {\n  if (!type) return;\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    metadata.serializedKey = keyName ? keyName : actualKeyName;\n    metadata.serializedType = type;\n    metadata.indexable = true; //this allows the type to be a stand alone function instead of a class\n\n    if (type !== Date && type !== RegExp && !TypeMap.get(type) && typeof type === \"function\") {\n      metadata.serializedType = {\n        Serialize: getSerializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.serializeIndexable = serializeIndexable; //deserializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\n\nfunction deserializeAs(keyNameOrType, keyName) {\n  if (!keyNameOrType) return;\n\n  var _a = getTypeAndKeyName(keyNameOrType, keyName),\n      key = _a.key,\n      type = _a.type;\n\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    metadata.deserializedKey = key ? key : actualKeyName;\n    metadata.deserializedType = type; //this allows the type to be a stand alone function instead of a class\n    //todo maybe add an explicit date and regexp deserialization function here\n\n    if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n      metadata.deserializedType = {\n        Deserialize: getDeserializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.deserializeAs = deserializeAs; //Supports deserializing of dictionary-like map objects, ie: { x: {}, y: {} }\n\nfunction deserializeIndexable(type, keyName) {\n  if (!type) return;\n  var key = keyName;\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    metadata.deserializedKey = key ? key : actualKeyName;\n    metadata.deserializedType = type;\n    metadata.indexable = true;\n\n    if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n      metadata.deserializedType = {\n        Deserialize: getDeserializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.deserializeIndexable = deserializeIndexable; //serializes and deserializes a type using 1.) a custom key name, 2.) a custom type, or 3.) both custom key and type\n\nfunction autoserializeAs(keyNameOrType, keyName) {\n  if (!keyNameOrType) return;\n\n  var _a = getTypeAndKeyName(keyNameOrType, keyName),\n      key = _a.key,\n      type = _a.type;\n\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    var serialKey = key ? key : actualKeyName;\n    metadata.deserializedKey = serialKey;\n    metadata.deserializedType = type;\n    metadata.serializedKey = serialKey;\n    metadata.serializedType = getSerializeFnForType(type);\n\n    if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n      metadata.deserializedType = {\n        Deserialize: getDeserializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.autoserializeAs = autoserializeAs; //Supports serializing/deserializing of dictionary-like map objects, ie: { x: {}, y: {} }\n\nfunction autoserializeIndexable(type, keyName) {\n  if (!type) return;\n  var key = keyName;\n  return function (target, actualKeyName) {\n    if (!target || !actualKeyName) return;\n    var metaDataList = TypeMap.get(target.constructor) || [];\n    var metadata = getMetaData(metaDataList, actualKeyName);\n    var serialKey = key ? key : actualKeyName;\n    metadata.deserializedKey = serialKey;\n    metadata.deserializedType = type;\n    metadata.serializedKey = serialKey;\n    metadata.serializedType = getSerializeFnForType(type);\n    metadata.indexable = true;\n\n    if (!TypeMap.get(type) && type !== Date && type !== RegExp && typeof type === \"function\") {\n      metadata.deserializedType = {\n        Deserialize: getDeserializeFnForType(type)\n      };\n    }\n\n    TypeMap.set(target.constructor, metaDataList);\n  };\n}\n\nexports.autoserializeIndexable = autoserializeIndexable; //helper class to contain serialization meta data for a property, each property\n//in a type tagged with a serialization annotation will contain an array of these\n//objects each describing one property\n\nvar MetaData = function () {\n  function MetaData(keyName) {\n    this.keyName = keyName;\n    this.serializedKey = null;\n    this.deserializedKey = null;\n    this.deserializedType = null;\n    this.serializedType = null;\n    this.indexable = false;\n  } //checks for a key name in a meta data array\n\n\n  MetaData.hasKeyName = function (metadataArray, key) {\n    for (var i = 0; i < metadataArray.length; i++) {\n      if (metadataArray[i].keyName === key) return true;\n    }\n\n    return false;\n  }; //clone a meta data instance, used for inheriting serialization properties\n\n\n  MetaData.clone = function (data) {\n    var metadata = new MetaData(data.keyName);\n    metadata.deserializedKey = data.deserializedKey;\n    metadata.serializedKey = data.serializedKey;\n    metadata.serializedType = data.serializedType;\n    metadata.deserializedType = data.deserializedType;\n    metadata.indexable = data.indexable;\n    return metadata;\n  };\n\n  return MetaData;\n}(); //merges two primitive objects recursively, overwriting or defining properties on\n//`instance` as they defined in `json`. Works on objects, arrays and primitives\n\n\nfunction mergePrimitiveObjects(instance, json) {\n  if (!json) return instance; //if we dont have a json value, just use what the instance defines already\n\n  if (!instance) return json; //if we dont have an instance value, just use the json\n  //for each key in the input json we need to do a merge into the instance object\n\n  Object.keys(json).forEach(function (key) {\n    var transformedKey = key;\n\n    if (typeof deserializeKeyTransform === \"function\") {\n      transformedKey = deserializeKeyTransform(key);\n    }\n\n    var jsonValue = json[key];\n    var instanceValue = instance[key];\n\n    if (Array.isArray(jsonValue)) {\n      //in the array case we reuse the items that exist already where possible\n      //so reset the instance array length (or make it an array if it isnt)\n      //then call mergePrimitiveObjects recursively\n      instanceValue = Array.isArray(instanceValue) ? instanceValue : [];\n      instanceValue.length = jsonValue.length;\n\n      for (var i = 0; i < instanceValue.length; i++) {\n        instanceValue[i] = mergePrimitiveObjects(instanceValue[i], jsonValue[i]);\n      }\n    } else if (jsonValue && typeof jsonValue === \"object\") {\n      if (!instanceValue || typeof instanceValue !== \"object\") {\n        instanceValue = {};\n      }\n\n      instanceValue = mergePrimitiveObjects(instanceValue, jsonValue);\n    } else {\n      //primitive case, just use straight assignment\n      instanceValue = jsonValue;\n    }\n\n    instance[transformedKey] = instanceValue;\n  });\n  return instance;\n} //takes an array defined in json and deserializes it into an array that ist stuffed with instances of `type`.\n//any instances already defined in `arrayInstance` will be re-used where possible to maintain referential integrity.\n\n\nfunction deserializeArrayInto(source, type, arrayInstance) {\n  if (!Array.isArray(arrayInstance)) {\n    arrayInstance = new Array(source.length);\n  } //extend or truncate the target array to match the source array\n\n\n  arrayInstance.length = source.length;\n\n  for (var i = 0; i < source.length; i++) {\n    arrayInstance[i] = DeserializeInto(source[i], type, arrayInstance[i] || new type());\n  }\n\n  return arrayInstance;\n} //takes an object defined in json and deserializes it into a `type` instance or populates / overwrites\n//properties on `instance` if it is provided.\n\n\nfunction deserializeObjectInto(json, type, instance) {\n  var metadataArray = TypeMap.get(type); //if we dont have an instance we need to create a new `type`\n\n  if (instance === null || instance === void 0) {\n    if (type) {\n      instance = new type();\n    }\n  } //if we dont have any meta data and we dont have a type to inflate, just merge the objects\n\n\n  if (instance && !type && !metadataArray) {\n    return mergePrimitiveObjects(instance, json);\n  } //if we dont have meta data just bail out and keep what we have\n\n\n  if (!metadataArray) {\n    invokeDeserializeHook(instance, json, type);\n    return instance;\n  } //for each property in meta data, try to hydrate that property with its corresponding json value\n\n\n  for (var i = 0; i < metadataArray.length; i++) {\n    var metadata = metadataArray[i]; //these are not the droids we're looking for (to deserialize), moving along\n\n    if (!metadata.deserializedKey) continue;\n    var serializedKey = metadata.deserializedKey;\n\n    if (metadata.deserializedKey === metadata.keyName) {\n      if (typeof deserializeKeyTransform === \"function\") {\n        serializedKey = deserializeKeyTransform(metadata.keyName);\n      }\n    }\n\n    var source = json[serializedKey];\n    if (source === void 0) continue;\n    var keyName = metadata.keyName; //if there is a custom deserialize function, use that\n\n    if (metadata.deserializedType && typeof metadata.deserializedType.Deserialize === \"function\") {\n      instance[keyName] = metadata.deserializedType.Deserialize(source);\n    } else if (Array.isArray(source)) {\n      if (metadata.deserializedType) {\n        instance[keyName] = deserializeArrayInto(source, metadata.deserializedType, instance[keyName]);\n      } else {\n        instance[keyName] = deserializeArray(source, null);\n      }\n    } else if ((typeof source === \"string\" || source instanceof Date) && metadata.deserializedType === Date.prototype.constructor) {\n      var deserializedDate = new Date(source);\n\n      if (instance[keyName] instanceof Date) {\n        instance[keyName].setTime(deserializedDate.getTime());\n      } else {\n        instance[keyName] = deserializedDate;\n      }\n    } else if (typeof source === \"string\" && type === RegExp) {\n      instance[keyName] = new RegExp(source);\n    } else if (source && typeof source === \"object\") {\n      if (metadata.indexable) {\n        instance[keyName] = deserializeIndexableObjectInto(source, metadata.deserializedType, instance[keyName]);\n      } else {\n        instance[keyName] = deserializeObjectInto(source, metadata.deserializedType, instance[keyName]);\n      }\n    } else {\n      instance[keyName] = source;\n    }\n  } //invoke our after deserialized callback if provided\n\n\n  invokeDeserializeHook(instance, json, type);\n  return instance;\n} //deserializes a bit of json into a `type`\n\n\nfunction Deserialize(json, type) {\n  if (Array.isArray(json)) {\n    return deserializeArray(json, type);\n  } else if (json && typeof json === \"object\") {\n    return deserializeObject(json, type);\n  } else if ((typeof json === \"string\" || json instanceof Date) && type === Date.prototype.constructor) {\n    return new Date(json);\n  } else if (typeof json === \"string\" && type === RegExp) {\n    return new RegExp(json);\n  } else {\n    return json;\n  }\n}\n\nexports.Deserialize = Deserialize; //takes some json, a type, and a target object and deserializes the json into that object\n\nfunction DeserializeInto(source, type, target) {\n  if (Array.isArray(source)) {\n    return deserializeArrayInto(source, type, target || []);\n  } else if (source && typeof source === \"object\") {\n    return deserializeObjectInto(source, type, target || new type());\n  } else {\n    return target || type && new type() || null;\n  }\n}\n\nexports.DeserializeInto = DeserializeInto; //deserializes an array of json into an array of `type`\n\nfunction deserializeArray(source, type) {\n  var retn = new Array(source.length);\n\n  for (var i = 0; i < source.length; i++) {\n    retn[i] = Deserialize(source[i], type);\n  }\n\n  return retn;\n}\n\nfunction invokeDeserializeHook(instance, json, type) {\n  if (type && typeof type.OnDeserialized === \"function\") {\n    type.OnDeserialized(instance, json);\n  }\n}\n\nfunction invokeSerializeHook(instance, json) {\n  if (typeof instance.constructor.OnSerialized === \"function\") {\n    instance.constructor.OnSerialized(instance, json);\n  }\n} //deserialize a bit of json into an instance of `type`\n\n\nfunction deserializeObject(json, type) {\n  var metadataArray = TypeMap.get(type); //if we dont have meta data, just decode the json and use that\n\n  if (!metadataArray) {\n    var inst = null;\n\n    if (!type) {\n      inst = JSON.parse(JSON.stringify(json));\n    } else {\n      inst = new type(); //todo this probably wrong\n\n      invokeDeserializeHook(inst, json, type);\n    }\n\n    return inst;\n  }\n\n  var instance = new type(); //for each tagged property on the source type, try to deserialize it\n\n  for (var i = 0; i < metadataArray.length; i++) {\n    var metadata = metadataArray[i];\n    if (!metadata.deserializedKey) continue;\n    var serializedKey = metadata.deserializedKey;\n\n    if (metadata.deserializedKey === metadata.keyName) {\n      if (typeof deserializeKeyTransform === \"function\") {\n        serializedKey = deserializeKeyTransform(metadata.keyName);\n      }\n    }\n\n    var source = json[serializedKey];\n    var keyName = metadata.keyName;\n    if (source === void 0) continue;\n\n    if (source === null) {\n      instance[keyName] = source;\n    } else if (metadata.deserializedType && typeof metadata.deserializedType.Deserialize === \"function\") {\n      instance[keyName] = metadata.deserializedType.Deserialize(source);\n    } else if (Array.isArray(source)) {\n      instance[keyName] = deserializeArray(source, metadata.deserializedType || null);\n    } else if ((typeof source === \"string\" || source instanceof Date) && metadata.deserializedType === Date.prototype.constructor) {\n      instance[keyName] = new Date(source);\n    } else if (typeof source === \"string\" && metadata.deserializedType === RegExp) {\n      instance[keyName] = new RegExp(json);\n    } else if (source && typeof source === \"object\") {\n      if (metadata.indexable) {\n        instance[keyName] = deserializeIndexableObject(source, metadata.deserializedType);\n      } else {\n        instance[keyName] = deserializeObject(source, metadata.deserializedType);\n      }\n    } else {\n      instance[keyName] = source;\n    }\n  }\n\n  invokeDeserializeHook(instance, json, type);\n  return instance;\n}\n\nfunction deserializeIndexableObject(source, type) {\n  var retn = {}; //todo apply key transformation here?\n\n  Object.keys(source).forEach(function (key) {\n    retn[key] = deserializeObject(source[key], type);\n  });\n  return retn;\n}\n\nfunction deserializeIndexableObjectInto(source, type, instance) {\n  //todo apply key transformation here?\n  Object.keys(source).forEach(function (key) {\n    instance[key] = deserializeObjectInto(source[key], type, instance[key]);\n  });\n  return instance;\n} //take an array and spit out json\n\n\nfunction serializeArray(source, type) {\n  var serializedArray = new Array(source.length);\n\n  for (var j = 0; j < source.length; j++) {\n    serializedArray[j] = Serialize(source[j], type);\n  }\n\n  return serializedArray;\n} //take an instance of something and try to spit out json for it based on property annotaitons\n\n\nfunction serializeTypedObject(instance, type) {\n  var json = {};\n  var metadataArray;\n\n  if (type) {\n    metadataArray = TypeMap.get(type);\n  } else {\n    metadataArray = TypeMap.get(instance.constructor);\n  }\n\n  for (var i = 0; i < metadataArray.length; i++) {\n    var metadata = metadataArray[i];\n    if (!metadata.serializedKey) continue;\n    var serializedKey = metadata.serializedKey;\n\n    if (metadata.serializedKey === metadata.keyName) {\n      if (typeof serializeKeyTransform === \"function\") {\n        serializedKey = serializeKeyTransform(metadata.keyName);\n      }\n    }\n\n    var source = instance[metadata.keyName];\n    if (source === void 0) continue;\n\n    if (Array.isArray(source)) {\n      json[serializedKey] = serializeArray(source, metadata.serializedType || null);\n    } else if (metadata.serializedType && typeof metadata.serializedType.Serialize === \"function\") {\n      //todo -- serializeIndexableObject probably isn't needed because of how serialize works\n      json[serializedKey] = metadata.serializedType.Serialize(source);\n    } else {\n      var value = Serialize(source);\n\n      if (value !== void 0) {\n        json[serializedKey] = value;\n      }\n    }\n  }\n\n  invokeSerializeHook(instance, json);\n  return json;\n} //take an instance of something and spit out some json\n\n\nfunction Serialize(instance, type) {\n  if (instance === null || instance === void 0) return null;\n\n  if (Array.isArray(instance)) {\n    return serializeArray(instance, type);\n  }\n\n  if (type && TypeMap.has(type)) {\n    return serializeTypedObject(instance, type);\n  }\n\n  if (instance.constructor && TypeMap.has(instance.constructor)) {\n    return serializeTypedObject(instance);\n  }\n\n  if (instance instanceof Date) {\n    return instance.toISOString();\n  }\n\n  if (instance instanceof RegExp) {\n    return instance.toString();\n  }\n\n  if (instance && typeof instance === 'object' || typeof instance === 'function') {\n    var keys = Object.keys(instance);\n    var json = {};\n\n    for (var i = 0; i < keys.length; i++) {\n      //todo this probably needs a key transform\n      json[keys[i]] = Serialize(instance[keys[i]]);\n    }\n\n    invokeSerializeHook(instance, json);\n    return json;\n  }\n\n  return instance;\n}\n\nexports.Serialize = Serialize;\n\nfunction GenericDeserialize(json, type) {\n  return Deserialize(json, type);\n}\n\nexports.GenericDeserialize = GenericDeserialize;\n\nfunction GenericDeserializeInto(json, type, instance) {\n  return DeserializeInto(json, type, instance);\n}\n\nexports.GenericDeserializeInto = GenericDeserializeInto; //these are used for transforming keys from one format to another\n\nvar serializeKeyTransform = null;\nvar deserializeKeyTransform = null; //setter for deserializing key transform\n\nfunction DeserializeKeysFrom(transform) {\n  deserializeKeyTransform = transform;\n}\n\nexports.DeserializeKeysFrom = DeserializeKeysFrom; //setter for serializing key transform\n\nfunction SerializeKeysTo(transform) {\n  serializeKeyTransform = transform;\n}\n\nexports.SerializeKeysTo = SerializeKeysTo; //this is kinda dumb but typescript doesnt treat enums as a type, but sometimes you still\n//want them to be serialized / deserialized, this does the trick but must be called after\n//the enum is defined.\n\nfunction SerializableEnumeration(e) {\n  e.Serialize = function (x) {\n    return e[x];\n  };\n\n  e.Deserialize = function (x) {\n    return e[x];\n  };\n}\n\nexports.SerializableEnumeration = SerializableEnumeration;","map":null,"metadata":{},"sourceType":"script"}